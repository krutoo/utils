# `useIntersection`

export const meta = {
  category: 'React',
  title: 'useIntersection',
};

Hook for detection element intersections with viewport or other elements by [IntersectionObserver](https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API).

```tsx
import { useIntersection } from '@krutoo/utils/react';

function App() {
  const ref = useRef<HTMLDivElement>(null);

  useIntersection(ref, entry => {
    if (entry.isIntersecting) {
      // ...element is in viewport
    }
  });

  return (
    <div ref={ref} className='widget'>
      Hello, World!
    </div>
  );
}
```

### Important: `threshold` and performance

Each known option' changing will provide recreating observer.

In case you have `threshold` as array - **provide stable array (constant or memoized)**.
Otherwise hook will be recreate observer on each render.

Wrong:

```jsx
// Each render hook will take new array
// So this options is "unstable" and provide recreating observer after each render
useIntersection(ref, callback, { threshold: [0.1, 0.2, 0.3] });
```

Right:

```jsx
// We memoize array, so it is "stable"
const threshold = useMemo(() => [0.1, 0.2, 0.3], []);

// So observer will be created once
useIntersection(ref, callback, { threshold });
```

Also right:

```jsx
// We use constant outside component, so it is "stable"
const THRESHOLD = [0.1, 0.2, 0.3];

function App() {
  // ...

  useIntersection(ref, callback, { threshold: THRESHOLD });

  // ...
}
```

### `IntersectionObserverContext`

Under the hood this hook uses `IntersectionObserverContext` to create observer.
`IntersectionObserverContext` by default uses global `window.IntersectionObserver`.

But using global instance trough context gives you ability to _replace implementation whenever you want_.

It means that you can:

- provide polyfill implementation for environments that don't support `IntersectionObserver`;
- provide implementation for SSR;
- provide different implementations for different subtrees of your UI;
- replace instance by mock in your unit tests.

For example next we will use [IntersectionObserverMock](./?path=/testing/intersection-observer-mock):

```tsx
import { test, expect, act, render } from '#testing';
import { useRef } from 'react';
import { useIntersection, IntersectionObserverContext } from '@krutoo/utils/react';
import { IntersectionObserverMock } from '@krutoo/utils/testing';

function MyWidget() {
  const ref = useRef(null);

  useIntersection(ref, entry => {
    ref.current.textContent = entry.isIntersecting ? 'I am on screen' : 'I am hidden';
  });

  return <div ref={ref} className='my-widget'></div>;
}

test('MyWidget should render message correctly', () => {
  let observer;

  const context = {
    getObserver(...args) {
      observer = new IntersectionObserverMock(...args);
      return observer;
    },
  };

  const { container } = render(
    <IntersectionObserverContext value={context}>
      <MyWidget />
    </IntersectionObserverContext>,
  );

  expect(container.textContent).toBe('I am hidden');

  act(() => {
    observer.simulateIntersection([
      {
        target: document.querySelector('.my-widget'),
        isIntersecting: true,
      },
    ]);
  });

  expect(container.textContent).toBe('I am on screen');
});
```

This example shows that you don't need to use environment that implements `IntersectionObserver` during testing.
So you can use [jsdom](https://github.com/jsdom/jsdom) for example.
